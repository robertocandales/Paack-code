{"version":3,"sources":["waitFor.js"],"names":["Object","defineProperty","exports","value","default","waitFor","waitForElement","React","_interopRequireWildcard","require","_act","_interopRequireDefault","_errors","_timers","obj","__esModule","_getRequireWildcardCache","WeakMap","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","DEFAULT_TIMEOUT","DEFAULT_INTERVAL","checkReactVersionAtLeast","major","minor","version","undefined","split","map","Number","actualMajor","actualMinor","waitForInternal","expectation","timeout","interval","stackTraceError","TypeError","Promise","resolve","reject","onDone","checkRealTimersCallback","checkExpectation","handleTimeout","error","lastError","copyStackTrace","Error","promiseStatus","result","then","resolvedValue","rejectedValue","jestFakeTimersAreEnabled","finished","clearTimeout","overallTimeoutTimer","usingFakeTimers","clearInterval","intervalId","setTimeout","fakeTimeRemaining","jest","advanceTimersByTime","setImmediate","setInterval","options","ErrorWithStack","optionsWithStackTrace","_timeout","_interval","throwRemovedFunctionError"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = waitFor;\nexports.waitForElement = waitForElement;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _act = _interopRequireDefault(require(\"./act\"));\n\nvar _errors = require(\"./helpers/errors\");\n\nvar _timers = require(\"./helpers/timers\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n/* globals jest */\nconst DEFAULT_TIMEOUT = 1000;\nconst DEFAULT_INTERVAL = 50;\n\nfunction checkReactVersionAtLeast(major, minor) {\n  if (React.version === undefined) return false;\n  const [actualMajor, actualMinor] = React.version.split('.').map(Number);\n  return actualMajor > major || actualMajor === major && actualMinor >= minor;\n}\n\nfunction waitForInternal(expectation, {\n  timeout = DEFAULT_TIMEOUT,\n  interval = DEFAULT_INTERVAL,\n  stackTraceError\n}) {\n  if (typeof expectation !== 'function') {\n    throw new TypeError('Received `expectation` arg must be a function');\n  } // eslint-disable-next-line no-async-promise-executor\n\n\n  return new Promise(async (resolve, reject) => {\n    let lastError, intervalId;\n    let finished = false;\n    let promiseStatus = 'idle';\n    const overallTimeoutTimer = (0, _timers.setTimeout)(handleTimeout, timeout);\n    const usingFakeTimers = (0, _timers.jestFakeTimersAreEnabled)();\n\n    if (usingFakeTimers) {\n      checkExpectation(); // this is a dangerous rule to disable because it could lead to an\n      // infinite loop. However, eslint isn't smart enough to know that we're\n      // setting finished inside `onDone` which will be called when we're done\n      // waiting or when we've timed out.\n      // eslint-disable-next-line no-unmodified-loop-condition\n\n      let fakeTimeRemaining = timeout;\n\n      while (!finished) {\n        if (!(0, _timers.jestFakeTimersAreEnabled)()) {\n          const error = new Error(`Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830`);\n\n          if (stackTraceError) {\n            (0, _errors.copyStackTrace)(error, stackTraceError);\n          }\n\n          reject(error);\n          return;\n        } // when fake timers are used we want to simulate the interval time passing\n\n\n        if (fakeTimeRemaining <= 0) {\n          return;\n        } else {\n          fakeTimeRemaining -= interval;\n        } // we *could* (maybe should?) use `advanceTimersToNextTimer` but it's\n        // possible that could make this loop go on forever if someone is using\n        // third party code that's setting up recursive timers so rapidly that\n        // the user's timer's don't get a chance to resolve. So we'll advance\n        // by an interval instead. (We have a test for this case).\n\n\n        jest.advanceTimersByTime(interval); // It's really important that checkExpectation is run *before* we flush\n        // in-flight promises. To be honest, I'm not sure why, and I can't quite\n        // think of a way to reproduce the problem in a test, but I spent\n        // an entire day banging my head against a wall on this.\n\n        checkExpectation(); // In this rare case, we *need* to wait for in-flight promises\n        // to resolve before continuing. We don't need to take advantage\n        // of parallelization so we're fine.\n        // https://stackoverflow.com/a/59243586/971592\n        // eslint-disable-next-line no-await-in-loop\n\n        await new Promise(resolve => (0, _timers.setImmediate)(resolve));\n      }\n    } else {\n      intervalId = setInterval(checkRealTimersCallback, interval);\n      checkExpectation();\n    }\n\n    function onDone(error, result) {\n      finished = true;\n      (0, _timers.clearTimeout)(overallTimeoutTimer);\n\n      if (!usingFakeTimers) {\n        clearInterval(intervalId);\n      }\n\n      if (error) {\n        reject(error);\n      } else {\n        // $FlowIgnore[incompatible-return] error and result are mutually exclusive\n        resolve(result);\n      }\n    }\n\n    function checkRealTimersCallback() {\n      if ((0, _timers.jestFakeTimersAreEnabled)()) {\n        const error = new Error(`Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830`);\n\n        if (stackTraceError) {\n          (0, _errors.copyStackTrace)(error, stackTraceError);\n        }\n\n        return reject(error);\n      } else {\n        return checkExpectation();\n      }\n    }\n\n    function checkExpectation() {\n      if (promiseStatus === 'pending') return;\n\n      try {\n        const result = expectation(); // $FlowIgnore[incompatible-type]\n\n        if (typeof (result === null || result === void 0 ? void 0 : result.then) === 'function') {\n          promiseStatus = 'pending'; // eslint-disable-next-line promise/catch-or-return\n\n          result.then(resolvedValue => {\n            promiseStatus = 'resolved';\n            onDone(null, resolvedValue);\n            return;\n          }, rejectedValue => {\n            promiseStatus = 'rejected';\n            lastError = rejectedValue;\n            return;\n          });\n        } else {\n          onDone(null, result);\n        } // If `callback` throws, wait for the next mutation, interval, or timeout.\n\n      } catch (error) {\n        // Save the most recent callback error to reject the promise with it in the event of a timeout\n        lastError = error;\n      }\n    }\n\n    function handleTimeout() {\n      let error;\n\n      if (lastError) {\n        error = lastError;\n\n        if (stackTraceError) {\n          (0, _errors.copyStackTrace)(error, stackTraceError);\n        }\n      } else {\n        error = new Error('Timed out in waitFor.');\n\n        if (stackTraceError) {\n          (0, _errors.copyStackTrace)(error, stackTraceError);\n        }\n      }\n\n      onDone(error, null);\n    }\n  });\n}\n\nasync function waitFor(expectation, options) {\n  // Being able to display a useful stack trace requires generating it before doing anything async\n  const stackTraceError = new _errors.ErrorWithStack('STACK_TRACE_ERROR', waitFor);\n  const optionsWithStackTrace = {\n    stackTraceError,\n    ...options\n  };\n\n  if (!checkReactVersionAtLeast(16, 9)) {\n    return waitForInternal(expectation, optionsWithStackTrace);\n  }\n\n  let result; //$FlowFixMe: `act` has incorrect flow typing\n\n  await (0, _act.default)(async () => {\n    result = await waitForInternal(expectation, optionsWithStackTrace);\n  }); //$FlowFixMe: either we have result or `waitFor` threw error\n\n  return result;\n}\n\nfunction waitForElement(expectation, _timeout = 4500, _interval = 50) {\n  (0, _errors.throwRemovedFunctionError)('waitForElement', 'migration-v2#waitfor-api-changes');\n  return Promise.reject();\n}"]}